// Generated by CoffeeScript 1.12.4
(function() {
  var Module, _, config, doAndDeleteCache, doAndRestoreCache, doWithoutCache, fakeLoad, hackErrorStackToGetCallerFile, ignoredCallerFiles, originalLoad, path, quibble, quibbles, requireWasCalledFromAFileThatHasQuibbledStuff;

  _ = {
    compact: require('lodash/fp/compact'),
    extendAll: require('lodash/fp/extendAll'),
    filter: require('lodash/fp/filter'),
    find: require('lodash/fp/find'),
    flow: require('lodash/fp/flow'),
    invokeMap: require('lodash/fp/invokeMap'),
    includes: require('lodash/fp/includes'),
    reject: require('lodash/fp/reject'),
    startsWith: require('lodash/fp/startsWith'),
    uniq: require('lodash/uniq'),
    tap: require('lodash/tap'),
    values: require('lodash/values')
  };

  Module = require('module');

  path = require('path');

  originalLoad = Module._load;

  config = null;

  quibbles = {};

  ignoredCallerFiles = [];

  module.exports = quibble = function(request, stub) {
    request = quibble.absolutify(request);
    Module._load = fakeLoad;
    quibbles[request] = {
      callerFile: hackErrorStackToGetCallerFile(),
      stub: (arguments.length < 2 ? config.defaultFakeCreator(request) : stub)
    };
    return quibbles[request].stub;
  };

  quibble.config = function(userConfig) {
    return config = _.extendAll({}, {
      defaultFakeCreator: function(request) {
        return {};
      }
    }, userConfig);
  };

  config = quibble.config();

  quibble.ignoreCallsFromThisFile = function(file) {
    if (file == null) {
      file = hackErrorStackToGetCallerFile(false);
    }
    return ignoredCallerFiles = _.uniq(ignoredCallerFiles.concat(file));
  };

  quibble.reset = function(hard) {
    if (hard == null) {
      hard = false;
    }
    Module._load = originalLoad;
    quibbles = {};
    config = quibble.config();
    if (hard) {
      return ignoredCallerFiles = [];
    }
  };

  quibble.absolutify = function(relativePath, parentFileName) {
    if (parentFileName == null) {
      parentFileName = hackErrorStackToGetCallerFile();
    }
    if (_.startsWith(relativePath, '/') || /^(\w|@)/.test(relativePath)) {
      return relativePath;
    }
    return path.resolve(path.dirname(parentFileName), relativePath);
  };

  fakeLoad = function(request, parent, isMain) {
    request = parent != null ? quibble.absolutify(request, parent.filename) : request;
    if (quibbles.hasOwnProperty(request)) {
      return quibbles[request].stub;
    } else if (requireWasCalledFromAFileThatHasQuibbledStuff()) {
      return doWithoutCache(request, parent, function() {
        return originalLoad(request, parent, isMain);
      });
    } else {
      return originalLoad(request, parent, isMain);
    }
  };

  requireWasCalledFromAFileThatHasQuibbledStuff = function() {
    var i, len, q, ref;
    ref = _.values(quibbles);
    for (i = 0, len = ref.length; i < len; i++) {
      q = ref[i];
      if (q.callerFile === hackErrorStackToGetCallerFile()) {
        return true;
      }
    }
  };

  doWithoutCache = function(request, parent, thingToDo) {
    var filename;
    filename = Module._resolveFilename(request, parent);
    if (Object.prototype.hasOwnProperty.call(Module._cache, filename)) {
      return doAndRestoreCache(filename, thingToDo);
    } else {
      return doAndDeleteCache(filename, thingToDo);
    }
  };

  doAndRestoreCache = function(filename, thingToDo) {
    var cachedThing;
    cachedThing = Module._cache[filename];
    delete Module._cache[filename];
    return _.tap(thingToDo(), function() {
      return Module._cache[filename] = cachedThing;
    });
  };

  doAndDeleteCache = function(filename, thingToDo) {
    return _.tap(thingToDo(), function() {
      return delete Module._cache[filename];
    });
  };

  hackErrorStackToGetCallerFile = function(includeGlobalIgnores) {
    var currentFile, e, originalFunc;
    if (includeGlobalIgnores == null) {
      includeGlobalIgnores = true;
    }
    originalFunc = Error.prepareStackTrace;
    try {
      Error.prepareStackTrace = function(e, stack) {
        return stack;
      };
      e = new Error();
      currentFile = e.stack[0].getFileName();
      return _.flow([
        _.invokeMap('getFileName'), _.compact, _.reject(function(f) {
          return includeGlobalIgnores && _.includes(f, ignoredCallerFiles);
        }), _.filter(path.isAbsolute), _.find(function(f) {
          return f !== currentFile;
        })
      ])(e.stack);
    } finally {
      Error.prepareStackTrace = originalFunc;
    }
  };

}).call(this);
